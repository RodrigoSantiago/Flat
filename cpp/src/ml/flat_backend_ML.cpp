/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "flat_backend_ML.h"
#include <memory.h>
#include <stdio.h>
#include <string.h>
#include <iostream>

#define M00 0
#define M01 4
#define M02 8
#define M03 12
#define M10 1
#define M11 5
#define M12 9
#define M13 13
#define M20 2
#define M21 6
#define M22 10
#define M23 14
#define M30 3
#define M31 7
#define M32 11
#define M33 15

static inline void matrix4_mul(float* mata, float* matb) {
    float tmp[16];
    tmp[M00] = mata[M00] * matb[M00] + mata[M01] * matb[M10] + mata[M02] * matb[M20] + mata[M03] * matb[M30];
    tmp[M01] = mata[M00] * matb[M01] + mata[M01] * matb[M11] + mata[M02] * matb[M21] + mata[M03] * matb[M31];
    tmp[M02] = mata[M00] * matb[M02] + mata[M01] * matb[M12] + mata[M02] * matb[M22] + mata[M03] * matb[M32];
    tmp[M03] = mata[M00] * matb[M03] + mata[M01] * matb[M13] + mata[M02] * matb[M23] + mata[M03] * matb[M33];
    tmp[M10] = mata[M10] * matb[M00] + mata[M11] * matb[M10] + mata[M12] * matb[M20] + mata[M13] * matb[M30];
    tmp[M11] = mata[M10] * matb[M01] + mata[M11] * matb[M11] + mata[M12] * matb[M21] + mata[M13] * matb[M31];
    tmp[M12] = mata[M10] * matb[M02] + mata[M11] * matb[M12] + mata[M12] * matb[M22] + mata[M13] * matb[M32];
    tmp[M13] = mata[M10] * matb[M03] + mata[M11] * matb[M13] + mata[M12] * matb[M23] + mata[M13] * matb[M33];
    tmp[M20] = mata[M20] * matb[M00] + mata[M21] * matb[M10] + mata[M22] * matb[M20] + mata[M23] * matb[M30];
    tmp[M21] = mata[M20] * matb[M01] + mata[M21] * matb[M11] + mata[M22] * matb[M21] + mata[M23] * matb[M31];
    tmp[M22] = mata[M20] * matb[M02] + mata[M21] * matb[M12] + mata[M22] * matb[M22] + mata[M23] * matb[M32];
    tmp[M23] = mata[M20] * matb[M03] + mata[M21] * matb[M13] + mata[M22] * matb[M23] + mata[M23] * matb[M33];
    tmp[M30] = mata[M30] * matb[M00] + mata[M31] * matb[M10] + mata[M32] * matb[M20] + mata[M33] * matb[M30];
    tmp[M31] = mata[M30] * matb[M01] + mata[M31] * matb[M11] + mata[M32] * matb[M21] + mata[M33] * matb[M31];
    tmp[M32] = mata[M30] * matb[M02] + mata[M31] * matb[M12] + mata[M32] * matb[M22] + mata[M33] * matb[M32];
    tmp[M33] = mata[M30] * matb[M03] + mata[M31] * matb[M13] + mata[M32] * matb[M23] + mata[M33] * matb[M33];
    memcpy(mata, tmp, sizeof(float) *  16);
}

static inline float matrix4_det(float* val) {
    return val[M30] * val[M21] * val[M12] * val[M03] - val[M20] * val[M31] * val[M12] * val[M03] - val[M30] * val[M11]
            * val[M22] * val[M03] + val[M10] * val[M31] * val[M22] * val[M03] + val[M20] * val[M11] * val[M32] * val[M03] - val[M10]
            * val[M21] * val[M32] * val[M03] - val[M30] * val[M21] * val[M02] * val[M13] + val[M20] * val[M31] * val[M02] * val[M13]
            + val[M30] * val[M01] * val[M22] * val[M13] - val[M00] * val[M31] * val[M22] * val[M13] - val[M20] * val[M01] * val[M32]
            * val[M13] + val[M00] * val[M21] * val[M32] * val[M13] + val[M30] * val[M11] * val[M02] * val[M23] - val[M10] * val[M31]
            * val[M02] * val[M23] - val[M30] * val[M01] * val[M12] * val[M23] + val[M00] * val[M31] * val[M12] * val[M23] + val[M10]
            * val[M01] * val[M32] * val[M23] - val[M00] * val[M11] * val[M32] * val[M23] - val[M20] * val[M11] * val[M02] * val[M33]
            + val[M10] * val[M21] * val[M02] * val[M33] + val[M20] * val[M01] * val[M12] * val[M33] - val[M00] * val[M21] * val[M12]
            * val[M33] - val[M10] * val[M01] * val[M22] * val[M33] + val[M00] * val[M11] * val[M22] * val[M33];
}

static inline bool matrix4_inv(float* val) {
    float tmp[16];
    float l_det = matrix4_det(val);
    if (l_det == 0) return false;
    tmp[M00] = val[M12] * val[M23] * val[M31] - val[M13] * val[M22] * val[M31] + val[M13] * val[M21] * val[M32] - val[M11]
        * val[M23] * val[M32] - val[M12] * val[M21] * val[M33] + val[M11] * val[M22] * val[M33];
    tmp[M01] = val[M03] * val[M22] * val[M31] - val[M02] * val[M23] * val[M31] - val[M03] * val[M21] * val[M32] + val[M01]
        * val[M23] * val[M32] + val[M02] * val[M21] * val[M33] - val[M01] * val[M22] * val[M33];
    tmp[M02] = val[M02] * val[M13] * val[M31] - val[M03] * val[M12] * val[M31] + val[M03] * val[M11] * val[M32] - val[M01]
        * val[M13] * val[M32] - val[M02] * val[M11] * val[M33] + val[M01] * val[M12] * val[M33];
    tmp[M03] = val[M03] * val[M12] * val[M21] - val[M02] * val[M13] * val[M21] - val[M03] * val[M11] * val[M22] + val[M01]
        * val[M13] * val[M22] + val[M02] * val[M11] * val[M23] - val[M01] * val[M12] * val[M23];
    tmp[M10] = val[M13] * val[M22] * val[M30] - val[M12] * val[M23] * val[M30] - val[M13] * val[M20] * val[M32] + val[M10]
        * val[M23] * val[M32] + val[M12] * val[M20] * val[M33] - val[M10] * val[M22] * val[M33];
    tmp[M11] = val[M02] * val[M23] * val[M30] - val[M03] * val[M22] * val[M30] + val[M03] * val[M20] * val[M32] - val[M00]
        * val[M23] * val[M32] - val[M02] * val[M20] * val[M33] + val[M00] * val[M22] * val[M33];
    tmp[M12] = val[M03] * val[M12] * val[M30] - val[M02] * val[M13] * val[M30] - val[M03] * val[M10] * val[M32] + val[M00]
        * val[M13] * val[M32] + val[M02] * val[M10] * val[M33] - val[M00] * val[M12] * val[M33];
    tmp[M13] = val[M02] * val[M13] * val[M20] - val[M03] * val[M12] * val[M20] + val[M03] * val[M10] * val[M22] - val[M00]
        * val[M13] * val[M22] - val[M02] * val[M10] * val[M23] + val[M00] * val[M12] * val[M23];
    tmp[M20] = val[M11] * val[M23] * val[M30] - val[M13] * val[M21] * val[M30] + val[M13] * val[M20] * val[M31] - val[M10]
        * val[M23] * val[M31] - val[M11] * val[M20] * val[M33] + val[M10] * val[M21] * val[M33];
    tmp[M21] = val[M03] * val[M21] * val[M30] - val[M01] * val[M23] * val[M30] - val[M03] * val[M20] * val[M31] + val[M00]
        * val[M23] * val[M31] + val[M01] * val[M20] * val[M33] - val[M00] * val[M21] * val[M33];
    tmp[M22] = val[M01] * val[M13] * val[M30] - val[M03] * val[M11] * val[M30] + val[M03] * val[M10] * val[M31] - val[M00]
        * val[M13] * val[M31] - val[M01] * val[M10] * val[M33] + val[M00] * val[M11] * val[M33];
    tmp[M23] = val[M03] * val[M11] * val[M20] - val[M01] * val[M13] * val[M20] - val[M03] * val[M10] * val[M21] + val[M00]
        * val[M13] * val[M21] + val[M01] * val[M10] * val[M23] - val[M00] * val[M11] * val[M23];
    tmp[M30] = val[M12] * val[M21] * val[M30] - val[M11] * val[M22] * val[M30] - val[M12] * val[M20] * val[M31] + val[M10]
        * val[M22] * val[M31] + val[M11] * val[M20] * val[M32] - val[M10] * val[M21] * val[M32];
    tmp[M31] = val[M01] * val[M22] * val[M30] - val[M02] * val[M21] * val[M30] + val[M02] * val[M20] * val[M31] - val[M00]
        * val[M22] * val[M31] - val[M01] * val[M20] * val[M32] + val[M00] * val[M21] * val[M32];
    tmp[M32] = val[M02] * val[M11] * val[M30] - val[M01] * val[M12] * val[M30] - val[M02] * val[M10] * val[M31] + val[M00]
        * val[M12] * val[M31] + val[M01] * val[M10] * val[M32] - val[M00] * val[M11] * val[M32];
    tmp[M33] = val[M01] * val[M12] * val[M20] - val[M02] * val[M11] * val[M20] + val[M02] * val[M10] * val[M21] - val[M00]
        * val[M12] * val[M21] - val[M01] * val[M10] * val[M22] + val[M00] * val[M11] * val[M22];

    float inv_det = 1.0f / l_det;
    val[M00] = tmp[M00] * inv_det;
    val[M01] = tmp[M01] * inv_det;
    val[M02] = tmp[M02] * inv_det;
    val[M03] = tmp[M03] * inv_det;
    val[M10] = tmp[M10] * inv_det;
    val[M11] = tmp[M11] * inv_det;
    val[M12] = tmp[M12] * inv_det;
    val[M13] = tmp[M13] * inv_det;
    val[M20] = tmp[M20] * inv_det;
    val[M21] = tmp[M21] * inv_det;
    val[M22] = tmp[M22] * inv_det;
    val[M23] = tmp[M23] * inv_det;
    val[M30] = tmp[M30] * inv_det;
    val[M31] = tmp[M31] * inv_det;
    val[M32] = tmp[M32] * inv_det;
    val[M33] = tmp[M33] * inv_det;
    return true;
}

static inline void matrix4_mulVec(float* mat, float* vec) {
    float x = vec[0] * mat[M00] + vec[1] * mat[M01] + vec[2] * mat[M02] + mat[M03];
    float y = vec[0] * mat[M10] + vec[1] * mat[M11] + vec[2] * mat[M12] + mat[M13];
    float z = vec[0] * mat[M20] + vec[1] * mat[M21] + vec[2] * mat[M22] + mat[M23];
    vec[0] = x;
    vec[1] = y;
    vec[2] = z;
}

static inline void matrix4_proj(float* mat, float* vec) {
    float inv_w = 1.0f / (vec[0] * mat[M30] + vec[1] * mat[M31] + vec[2] * mat[M32] + mat[M33]);
    float x = (vec[0] * mat[M00] + vec[1] * mat[M01] + vec[2] * mat[M02] + mat[M03]) * inv_w;
    float y = (vec[0] * mat[M10] + vec[1] * mat[M11] + vec[2] * mat[M12] + mat[M13]) * inv_w;
    float z = (vec[0] * mat[M20] + vec[1] * mat[M21] + vec[2] * mat[M22] + mat[M23]) * inv_w;
    vec[0] = x;
    vec[1] = y;
    vec[2] = z;
}

static inline void matrix4_rot(float* mat, float* vec) {
    float x = vec[0] * mat[M00] + vec[1] * mat[M01] + vec[2] * mat[M02];
    float y = vec[0] * mat[M10] + vec[1] * mat[M11] + vec[2] * mat[M12];
    float z = vec[0] * mat[M20] + vec[1] * mat[M21] + vec[2] * mat[M22];
    vec[0] = x;
    vec[1] = y;
    vec[2] = z;
}

JNIEXPORT void JNICALL Java_flat_backend_ML_mul (JNIEnv * jEnv, jclass jClass, jfloatArray mata, jfloatArray matb) {
    float * _mata = (float *)jEnv->GetPrimitiveArrayCritical(mata, 0);
    float * _matb = (float *)jEnv->GetPrimitiveArrayCritical(matb, 0);

    matrix4_mul(_mata, _matb);

    jEnv->ReleasePrimitiveArrayCritical(matb, _matb, 0);
    jEnv->ReleasePrimitiveArrayCritical(mata, _mata, 0);
}

JNIEXPORT void JNICALL Java_flat_backend_ML_mulVec___3F_3F(JNIEnv * jEnv, jclass jClass, jfloatArray mat, jfloatArray vec) {
    float * _mat = (float *)jEnv->GetPrimitiveArrayCritical(mat, 0);
    float * _vec = (float *)jEnv->GetPrimitiveArrayCritical(vec, 0);

    matrix4_mulVec(_mat, _vec);

    jEnv->ReleasePrimitiveArrayCritical(vec, _vec, 0);
    jEnv->ReleasePrimitiveArrayCritical(mat, _mat, 0);

}

JNIEXPORT void JNICALL Java_flat_backend_ML_mulVec___3F_3FIII(JNIEnv * jEnv, jclass jClass, jfloatArray mat, jfloatArray vecs, jint offset, jint numVecs, jint stride) {
    float * _mat = (float *)jEnv->GetPrimitiveArrayCritical(mat, 0);
    float * _vecs = (float *)jEnv->GetPrimitiveArrayCritical(vecs, 0);

    float* vecPtr =  _vecs + offset;
    for(int i = 0; i < numVecs; i++) {
        matrix4_mulVec(_mat, vecPtr);
        vecPtr += stride;
    }

    jEnv->ReleasePrimitiveArrayCritical(vecs, _vecs, 0);
    jEnv->ReleasePrimitiveArrayCritical(mat, _mat, 0);
}

JNIEXPORT void JNICALL Java_flat_backend_ML_prj___3F_3F(JNIEnv * jEnv, jclass jClass, jfloatArray mat, jfloatArray vec) {
    float * _mat = (float *)jEnv->GetPrimitiveArrayCritical(mat, 0);
    float * _vec = (float *)jEnv->GetPrimitiveArrayCritical(vec, 0);

    matrix4_proj(_mat, _vec);

    jEnv->ReleasePrimitiveArrayCritical(vec, _vec, 0);
    jEnv->ReleasePrimitiveArrayCritical(mat, _mat, 0);

}

JNIEXPORT void JNICALL Java_flat_backend_ML_prj___3F_3FIII (JNIEnv * jEnv, jclass jClass, jfloatArray mat, jfloatArray vecs, jint offset, jint numVecs, jint stride) {
    float * _mat = (float *)jEnv->GetPrimitiveArrayCritical(mat, 0);
    float * _vecs = (float *)jEnv->GetPrimitiveArrayCritical(vecs, 0);

    float* vecPtr = _vecs + offset;
    for(int i = 0; i < numVecs; i++) {
        matrix4_proj(_mat, vecPtr);
        vecPtr += stride;
    }

    jEnv->ReleasePrimitiveArrayCritical(vecs, _vecs, 0);
    jEnv->ReleasePrimitiveArrayCritical(mat, _mat, 0);
}

JNIEXPORT void JNICALL Java_flat_backend_ML_rot___3F_3F (JNIEnv * jEnv, jclass jClass, jfloatArray mat, jfloatArray vec) {
    float * _mat = (float *)jEnv->GetPrimitiveArrayCritical(mat, 0);
    float * _vec = (float *)jEnv->GetPrimitiveArrayCritical(vec, 0);

    matrix4_rot(_mat, _vec);

    jEnv->ReleasePrimitiveArrayCritical(vec, _vec, 0);
    jEnv->ReleasePrimitiveArrayCritical(mat, _mat, 0);
}

JNIEXPORT void JNICALL Java_flat_backend_ML_rot___3F_3FIII (JNIEnv * jEnv, jclass jClass, jfloatArray mat, jfloatArray vecs, jint offset, jint numVecs, jint stride) {
    float * _mat = (float *)jEnv->GetPrimitiveArrayCritical(mat, 0);
    float * _vecs = (float *)jEnv->GetPrimitiveArrayCritical(vecs, 0);

    float* vecPtr = _vecs + offset;
    for(int i = 0; i < numVecs; i++) {
        matrix4_rot(_mat, vecPtr);
        vecPtr += stride;
    }

    jEnv->ReleasePrimitiveArrayCritical(vecs, _vecs, 0);
    jEnv->ReleasePrimitiveArrayCritical(mat, _mat, 0);
}

JNIEXPORT jboolean JNICALL Java_flat_backend_ML_inv (JNIEnv * jEnv, jclass jClass, jfloatArray values) {
    float * _values = (float *)jEnv->GetPrimitiveArrayCritical(values, 0);

    jboolean ret = matrix4_inv(_values);

    jEnv->ReleasePrimitiveArrayCritical(values, _values, 0);

    return ret;
}

JNIEXPORT jfloat JNICALL Java_flat_backend_ML_det(JNIEnv * jEnv, jclass jClass, jfloatArray values) {
    float * _values = (float *)jEnv->GetPrimitiveArrayCritical(values, 0);

    jboolean ret = matrix4_det(_values);

    jEnv->ReleasePrimitiveArrayCritical(values, _values, 0);

    return ret;
}
